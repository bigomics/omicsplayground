Profiling
================================================================================

Inputs {.sidebar data-width=250}
--------------------------------------------------------------------------------

<br> **Cell Profiling**. Visualize the distribution of (inferred)
immune cell types, expressed genes and pathway activation.


```{r}
##----------------------------------------------------------------------
## More Info (pop up window)
##----------------------------------------------------------------------

##actionLink("pr_info", "More details ...")
tipify(actionLink("pr_info", "Info", icon=icon("info-circle")),
       "Show more information about this module.")

pr_infotext =
    "The <strong>Cell Profiling Module</strong> infers the type of cells using computational deconvolution methods and reference datasets from the literature. Currently, we have implemented a total of 8 methods and 9 reference datasets to predict immune cell types (4 datasets), tissue types (2 datasets), cell lines (2 datasets) and cancer types (1 dataset). However, we plan to expand the collection of methods and databases and to infer other cell types.

<br><br>The <strong>Proportions tab</strong> visualizes the interrelationships between two categorical variables (so-called cross tabulation). Although this feature is very suitable for a single-cell sequencing data, it provides useful information about the proportion of different cell types in samples obtained by the bulk sequencing method.

<br><br>For each combination of gene pairs, the platform can generate a cytometry-like plot of samples under the <strong>Cytoplot</strong> tab. The aim of this feature is to observe the distribution of samples in relation to the selected gene pairs. For instance, when applied to single-cell sequencing data from immunological cells, it can mimic flow cytometry analysis and distinguish T helper cells from the other T cells by selecting the CD4 and CD8 gene combination.

<br><br>The <strong>Markers</strong> section provides potential marker genes, which are the top N=36 genes with the highest standard deviation within the expression data across the samples. For every gene, it produces a t-SNE plot of samples, with samples colored in red when the gene is overexpressed in corresponding samples. Users can also restrict the marker analysis by selecting a particular functional group in which genes are divided into 89 groups, such as chemokines, transcription factors, genes involved in immune checkpoint inhibition, and so on.

<br><br>It is also possible to perform a copy number variation analysis under the <strong>CNV tab</strong>. The copy number is estimated from gene expression data by computing a moving average of the relative expression along the chromosomes. CNV generates a heatmap of samples versus chromosomes, where samples can be annotated further with a phenotype class provided in the data."

observeEvent( input$pr_info, {
    showModal(modalDialog(
        title = HTML("<strong>Cell Profiling Module</strong>"),
        HTML(pr_infotext),
        easyClose = TRUE ))
})
```

<br><br>

```{r}
br();br();br();
tipify( actionLink("pr_options", "Options", icon=icon("cog", lib = "glyphicon")),
       "Toggle advanced options", placement="top")

br();br();
conditionalPanel(
    "input.pr_options % 2 == 1",
    tagList(
        selectInput("pr_samplefilter","Filter samples:", choices=NULL, multiple=TRUE),
        radioButtons('pr_clustmethod',NULL,c("tsne","pca"), inline=TRUE, selected="tsne"),
        ##radioButtons('pr_labelmode',NULL,c("label","legend"), inline=TRUE),
        ##checkboxInput("pr_toggleinfo", "toggle info", TRUE),
        checkboxInput("pr_rowscale", "scale rows", TRUE)
    )
)

## observeEvent(input$pr_showinfo, {
##     if(input$pr_showinfo%%2) {
##         toggleDropdownButton("pr_icpplot_info")
##         toggleDropdownButton("pr_markersplot_info")
##         toggleDropdownButton("pr_cytoplot_info")
##         toggleDropdownButton("pr_cnaplot_info")
##         toggleDropdownButton("pr_phenoplot_info")
##         toggleDropdownButton("pr_xtabplot_info")
##     }
## })

if(PRO.VERSION) {
    conditionalPanel(
        "input.pr_options % 2 == 1",
        tagList(
            checkboxInput("pr_group", "group", FALSE)
            ##radioButtons('pr_binoptions','bin',c(0,10,20), inline=TRUE)
            ##selectInput("pr_dcmethod","Method:", choices=NULL, multiple=FALSE)
            ##selectInput("pr_refset", "Reference:", choices=NULL, width='80%')
        )
    )    
}

## update filter choices upon change of data set 
observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ## levels for sample filter
    levels <- getLevels(ngs$Y)
    updateSelectInput(session, "pr_samplefilter", choices=levels)
})

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)

    refsets = "LM22"
    ##if(PRO.VERSION) refsets <- sort(names(ngs$deconv))
    ##if(PRO.VERSION) updateSelectInput(session,"pr_refset",choices=refsets, selected="LM22")
    refsets <- sort(names(ngs$deconv))
    refsel <- grep("LM22",refsets,value=TRUE)
    updateSelectInput(session,"pr_refset",choices=refsets, selected=refsel)
    ## updateSelectInput(session,"pr_refset2",choices=refsets, selected=refsel)
       
    dcmethods <- names(ngs$deconv[[1]])
    dcsel <- intersect(c("meta.prod","meta"),dcmethods)[1]
    updateSelectInput(session, "pr_dcmethod", choices=dcmethods, selected=dcsel)
})

```

```{r}
pfGetClusterPositions <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    ##zx <- filtered_matrix1()
    zx = ngs$X
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    if(length(kk)==0) return(NULL)
    
    zx <- zx[,kk,drop=FALSE]
    zx = head(zx[order(-apply(zx,1,sd)),],1000)
    zx = t(scale(t(zx)))  ## scale??

    if(FALSE && input$pr_group) {
        grp = ngs$Y[colnames(zx),"group"]
        zx = t(apply( zx, 1, function(x) tapply(x, grp, mean)))
    }

    pos = NULL
    if(input$pr_clustmethod=="tsne") {
        require(Rtsne)
        tsne.dim = 3
        ##do3d <- grepl("3D", as.character(input$pr_clustmethod))
        do3d <- ("3D" %in% input$pca.options)
        tsne.dim = c(2,3)[ 1 + 1*do3d]
        force.compute = FALSE
        ## force.compute = TRUE        
        if(!force.compute && tsne.dim==2 && !is.null(ngs$tsne2d) ) {
            pos <- ngs$tsne2d[colnames(zx),]
        } else if(!force.compute && tsne.dim==3 && !is.null(ngs$tsne3d) ) {
            pos <- ngs$tsne3d[colnames(zx),]
        } else {
            perplexity = max(min(30,ncol(zx)/4),1)
            perplexity = min((ncol(zx)-1)/3, 30)
            perplexity
            pos <- Rtsne( t(zx), dim=tsne.dim, check_duplicated=FALSE,
                         num_threads=100, ##Y_init=Y_init, 
                         perplexity=perplexity )$Y
        }
    } else {
        ##cat("pfGetClusterPositions:: computing PCA/SVD...\n")
        require(irlba)
        ##pos <- cmdscale(dist(t(zx)), k=3)
        ##pos = svd(zx,nv=3)$v
        pos = irlba(zx,nv=3)$v        
    }
    
    pos = scale(pos) ## scale 
    colnames(pos) = paste0("dim",1:ncol(pos))
    rownames(pos) = colnames(zx)    

    if(0) {
        tt = factor(ngs$sample$tissue.type)
        ct = factor(ngs$sample$cell.type)
        jj = which(tt %in% c("HCC","nonHCC"))
        jj = which(tt %in% c("Blood","nonHCC"))
        fc = gx.limma( zx[,jj], as.character(tt[jj]), fdr=1)        
        fc = gx.limma( zx[,], 1*(tt=="Blood"), fdr=1)
        gg = head(rownames(fc),100)
        ## gg = tail(rownames(fc),20)

        require(Rtsne.multicore)
        pos = svd(zx[gg,],nv=3)$v
        ##pos = Rtsne.multicore( t(zx[gg,]) )$Y
        par(mfrow=c(2,2))
        scatterD3(pos[,1], pos[,2], col_var=tt, symbol_var=ct,
                  point_size=150 )

        
    }

    ##if(input$pca.gx=="<cluster>")
    require(igraph)
    dist = as.dist(dist(pos))
    gr = graph_from_adjacency_matrix(
        1.0/dist, diag=FALSE, mode="undirected")
    clust <- cluster_louvain(gr)$membership

    ##cat("pfGetClusterPositions:: done!\n")
    return( list(pos=pos, clust=clust) )
})

```


Col {.tabset data-width=625}
----------------------------------------------------------------------------------------

### Cell type

```{r}

getDeconvResults <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    method = "meta"
    method <- input$pr_dcmethod
    if(is.null(method)) return(NULL)
    
    refset = "LM22"
    ##if(PRO.VERSION) refset <- input$pr_refset
    refset <- input$pr_refset
    if(!("deconv" %in% names(ngs))) return(NULL)
    results <- ngs$deconv[[refset]][[method]]
    ## threshold everything (because DCQ can be negative!!!)
    results <- pmax(results,0)
    
    return(results)
})

pr_icpplotFUNC <- reactive({
    require(RColorBrewer)
    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    clust <- pfGetClusterPositions()
    if(is.null(clust)) return(NULL)
    pos <- ngs$tsne2d
    pos <- clust$pos
    
    score <- ngs$deconv[["LM22"]][["meta"]]
    score = getDeconvResults()
    if(is.null(score) || length(score)==0  ) return(NULL)
    
    ## normalize
    score <- score[rownames(pos),,drop=FALSE]
    score[is.na(score)] <- 0
    score <- pmax(score,0)
    ##score <- score - min(score,na.rm=TRUE) + 0.01 ## subtract background??
    ##score <- score / (1e-20 + sqrt(rowMeans(score**2,na.rm=TRUE)))
    score <- score / (1e-20 + rowSums(score))
    score <- tanh(score/mean(abs(score)))
    score <- score / max(score,na.rm=TRUE)
    summary(as.vector(score))

    ## take top10 features
    jj.top <- unique(as.vector(apply(score,1,function(x) head(order(-x),10))))
    score <- score[,jj.top]
    score <- score[,order(-colMeans(score**2))]    
    score <- score[,1:min(50,ncol(score))]
    ii <- hclust(dist(score))$order
    jj <- hclust(dist(t(score)))$order
    score <- score[ii,jj]
    score0 <- score
    pos <- pos[rownames(score),]
    
    if(PRO.VERSION && input$pr_group && input$pr_view!="distribution") {
        grp <- ngs$samples[rownames(score),"group"]
        pos <- apply(pos,2,function(x) tapply(x,grp,median))
        score <- apply(score,2,function(x) tapply(x,grp,mean))
        ii <- hclust(dist(score))$order
        jj <- hclust(dist(t(score)))$order
        score <- score[ii,jj]        
    }    
    b0 <- 1 + 0.85*pmax(30 - ncol(score), 0)

    if(input$pr_view=="dotmap") {
        require(corrplot)
        ##gx.heatmap(score)
        par(mfrow=c(1,1), mar=c(0,0,8,1), oma=c(1,1,1,1)*0.5 )
        score3 <- score**1.5
        rownames(score3) <- paste("",rownames(score3),"  ")
        tl.srt=90
        tl.cex=ifelse(nrow(score)>60,0.7,0.85)
        if(max(sapply(rownames(score3),nchar))>30) tl.srt=45
        corrplot( t(score3), mar=c(b0,1,4,1),
                 cl.lim = c(0,max(score3)), cl.pos = "n",
                 tl.cex = tl.cex, tl.col = "grey20",
                 tl.srt = tl.srt )
    }

    if(input$pr_view=="heatmap") {

        if(PRO.VERSION) {            

            kk <- head(colnames(score)[order(-colMeans(score**2))],18)
            kk <- intersect(colnames(score),kk)
            all.scores <- ngs$deconv[["LM22"]]
            all.scores <- ngs$deconv[[input$pr_refset]]
            if(input$pr_group && input$pr_view!="distribution") {
                grp <- ngs$samples[rownames(all.scores[[1]]),"group"]
                for(i in 1:length(all.scores)) {
                    all.scores[[i]] <- apply(all.scores[[i]],2,
                                             function(x) tapply(x,grp,mean))
                    ii <- rownames(score)
                    all.scores[[i]] <- all.scores[[i]][ii,kk]
                }
            }    

            nm <- length(all.scores)
            m=3;n=2
            if(nm>6) {m=3;n=3}
            if(nm>9) {m=4;n=3}
            rr <- 2+max(nchar(colnames(score)))/2
            par(mfrow=c(m,n), mar=c(0,0.3,2,0.3), oma=c(10,0,0,rr), xpd=TRUE)
            k=1
            for(k in 1:length(all.scores)) {
                ii <- rownames(score)
                score1 <- all.scores[[k]][ii,kk]
                ##score1 <- score1[rownames(score0),kk]
                if(k%%n!=0) colnames(score1) <- rep("",ncol(score1))
                if((k-1)%/%n!=(nm-1)%/%n) rownames(score1) <- rep("",nrow(score1))
                score1 <- score1 / (1e-8+rowSums(score1))
                if(nrow(score1) > 100)  rownames(score1) <- rep("",nrow(score1))
                gx.imagemap( t(score1**1), cex=0.85, main="", clust=FALSE)
                title(main=names(all.scores)[k], cex.main=1.1, line=0.4, font.main=1)
            }
            
        } else {
            score1 <- score
            score1 <- score1 / (1e-8+rowSums(score1))            
            if(nrow(score1) > 100)  rownames(score1) <- rep("",nrow(score))
            gx.heatmap( t(score1**2), scale="none", 
                       cexRow=1, cexCol=0.6, col=heat.colors(16),
                       mar=c(b0,15), key=FALSE, keysize=0.5)
        }
        
    }    
    
    if(input$pr_view=="distribution") {
        
        cex1 = 1.2
        cex1 <- 0.9*c(2.2,1.1,0.6,0.3)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]
        klrpal = colorRampPalette(c("grey90", "grey50", "red3"))(16)
        ##klrpal = paste0(col2hex(klrpal),"AA")    
        klrpal = paste0(col2hex(klrpal),"66")
        
        par(mfrow=c(5,5), mar=c(0.2,0.2,1.8,0.2), oma=c(1,1,1,1)*0.8 )
        par(mfrow=c(5,5), mar=c(0,0.2,0.5,0.2), oma=c(1,1,6,1)*0.5)
        if(ncol(score)>25) par(mfrow=c(6,6), mar=c(0,0.2,0.5,0.2)*0.6)
        i=1    
        
        jj <- head(order(-colMeans(score**2)),36)
        jj <- jj[order(colnames(score)[jj])]
        colnames(score)[jj]
        for(j in jj) {
            gx = pmax(score[,j],0)
            gx = 1+round(15*gx/(1e-8+max(score)))
            klr0 = klrpal[gx]
            ii <- order(gx)
            ## ii <- sample(nrow(pos))
            plot( pos[ii,], pch=19, cex=1*cex1, col=klr0[ii],
                 xlim=1.2*range(pos[,1]), ylim=1.2*range(pos[,2]),
                 fg = gray(0.8), bty = "o", xaxt='n', yaxt='n',
                 xlab="", ylab="")
            legend( "topleft", legend=colnames(score)[j], bg="#AAAAAA88",
                   cex=1.2, text.font=1, y.intersp=0.8, bty="n",
                   inset=c(-0.05,-0.0) )
        }

        refset <- input$pr_refset
        mtext( refset, outer=TRUE, line=0.5, cex=1.2)
        
    }
})

pr_icp.opts = tagList(
    ##radioButtons('pr_view',NULL,c("distribution","dotmap","heatmap"), inline=TRUE),
    selectInput("pr_view","plot type:", choices=c("distribution","dotmap","heatmap")),
    selectInput("pr_refset", "reference:", choices=NULL),
    selectInput("pr_dcmethod","method:", choices=NULL)
)

pr_icp_module <- plotModule(
    "pr_icpplot", pr_icpplotFUNC,
    title = "Cell type profiling (deconvolution)",
    info.text = "<strong>Cell type profiling</strong> infers the type of cells using computational deconvolution methods and reference datasets from the literature. Currently, we have implemented a total of 8 methods and 9 reference datasets to predict immune cell types (4 datasets), tissue types (2 datasets), cell lines (2 datasets) and cancer types (1 dataset). However, we plan to expand the collection of methods and databases and to infer other cell types.",
    options = pr_icp.opts,
    pdf.width=8, pdf.height=8, res=95
)
output$pr_icpplot     <- pr_icp_module$render
output$pr_icpplot_pdf <- pr_icp_module$pdf

fillCol(flex = c(NA,1), 
        pr_icp_module$buttons,
        ##inputPanel(
        ##    tipify(selectInput("pr_refset2",NULL, choices=NULL),"Reference set for deconvolution")
        ##),
        plotOutput("pr_icpplot", height = "100%", width = "100%")
        )

```

> **Cell type profiling (deconvolution).** The cell type can be computationally inferred using so-called deconvolution methods by matching the (absolute) expression profile to a known reference set. This reference set can be a cell type reference database but also cancer types, tissue types or cell lines. Reference set: `r renderText(input$pr_refset)`. Deconvolution method: `r renderText(input$pr_dcmethod)`


### Markers

```{r}

##output$pr_markersplot <- renderPlot({
pr_markersplotFUNC <- reactive({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    clust <- pfGetClusterPositions()
    if(is.null(clust)) return(NULL)
    pos <- ngs$tsne2d
    pos <- clust$pos
    
    ##markers <- ngs$families[["CD family"]]
    if(is.null(input$pr_features)) return(NULL)
    if(input$pr_features=="") return(NULL)

    term = ""
    if(input$pr_level=="gene") {
        markers <- ngs$families[["Transcription factors (ChEA)"]]
        if(input$pr_search!="") {
            term = input$pr_search
            jj <- grep(term, ngs$genes$gene_name, ignore.case=TRUE )
            markers <- ngs$genes$gene_name[jj]
            term = paste("filter:",term)
        } else if(input$pr_features %in% names(ngs$families)) {
            markers <- ngs$families[[input$pr_features]]
            term = input$pr_features
        } else {
            markers <- ngs$genes$gene_name
        }
        ##markers <- intersect(markers, rownames(ngs$X))       
        markers <- intersect(markers,ngs$genes$gene_name)
        jj <- match(markers,ngs$genes$gene_name)
        pmarkers <- intersect(rownames(ngs$genes)[jj],rownames(ngs$X))
        gx <- ngs$X[pmarkers,rownames(pos),drop=FALSE]
    } else if(input$pr_level=="geneset") {
        ##markers <- ngs$families[["Immune checkpoint (custom)"]]
        markers <- COLLECTIONS[[1]]
        if(is.null(input$pr_features)) return(NULL)
        ft <- input$pr_features
        if(input$pr_search=="" && ft %in% names(COLLECTIONS)) {
            markers <- COLLECTIONS[[input$pr_features]]
            markers <- intersect(markers, rownames(ngs$gsetX))
            term = input$pr_features
        } else if(input$pr_search!="") {
            term = input$pr_search
            jj <- grep(term, rownames(ngs$gsetX), ignore.case=TRUE )
            markers <- rownames(ngs$gsetX)[jj]
            term = paste("filter:",term)
        } else {
            markers <- rownames(ngs$gsetX)
        }
        gx <- ngs$gsetX[markers,rownames(pos),drop=FALSE]
    } else {
        cat("fatal error")
        return(NULL)
    }
    
    ## prioritize gene with large variance (groupwise)
    grp <- as.character(ngs$samples[rownames(pos),"group"])
    zx <- t(apply(gx,1,function(x) tapply(x,grp,mean)))
    gx <- gx[order(-apply(zx,1,sd)),,drop=FALSE]
    gx <- gx - min(gx,na.rm=TRUE) + 0.01 ## subtract background??    
    rownames(gx) = sub(".*:","",rownames(gx))
       
    ##gx <- tanh(gx/sd(gx) ) ## softmax
    cex1 = 1.0
    cex1 <- 0.8*c(2.2,1.1,0.6,0.3)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]
    klrpal <- colorRampPalette(c("grey90", "grey80", "grey70", "grey60","red4", "red3"))(16)
    klrpal = colorRampPalette(c("grey90", "grey60", "red3"))(16)
    klrpal = paste0(col2hex(klrpal),"66")

    NP=25
    if(input$pr_level=="gene") NP=36
    top.gx = head(gx,NP)  ## match number of plot below!
    top.gx = top.gx[order(rownames(top.gx)),,drop=FALSE]
    top.gx = pmax(top.gx,0)
    ##top.gx <- tanh(top.gx/mean(top.gx))

    plevel="gene"
    plevel <- input$pr_level
    
    ## plot(0, type="n")  %>% withSpinner(color="#0dc5c1")  
    par(mfrow=c(1,1)*sqrt(NP), mar=c(0,0.2,0.5,0.2)*0.6, oma=c(1,1,1,1)*0.5)
    par(mfrow=c(1,1)*sqrt(NP), mar=c(0,0.2,0.5,0.2)*0.6, oma=c(1,1,6,1)*0.5)
    ##par(mfrow=c(6,6), mar=c(0,0.2,0.5,0.2), oma=c(1,1,1,1)*0.5)
    i=1    
    for(i in 1:min(NP,nrow(top.gx))) {

        colvar = pmax(top.gx[i,],0) 
        colvar = 1+round(15*(colvar/(0.7*max(colvar)+0.3*max(top.gx))))
        klr0 = klrpal[colvar]

        ii <- order(colvar)
        ##ii <- sample(nrow(pos))
        plot( pos[ii,], pch=19, cex=cex1, col=klr0[ii],
             xlim=1.1*range(pos[,1]), ylim=1.1*range(pos[,2]),
             fg = gray(0.8), bty = "o",
             xaxt='n', yaxt='n', xlab="tSNE1", ylab="tSNE2")

        if(plevel=="gene") {
            gene <- sub(".*:","",rownames(top.gx)[i])
            ##title( gene, cex.main=1.0, line=0.3, col="grey40", font.main=1)
            legend( "topleft", legend=gene, bg="#AAAAAA88",
                   cex=1.2, text.font=1, y.intersp=0.8,
                   bty="n", inset=c(-0.05,-0.0) )
        } else {
            gset <- sub(".*:","",rownames(top.gx)[i])
            gset1 <- breakstring(substring(gset,1,80),24,force=TRUE)
            gset1 <- tolower(gset1) 
            ##title( gset1, cex.main=0.9, line=0.4, col="grey40", font.main=1)
            legend( "topleft", legend=gset1, cex=0.95, bg="#AAAAAA88",
                   text.font=2, y.intersp=0.8, bty="n",
                   inset=c(-0.05,-0.0) )
        }
    }

    mtext(term, outer=TRUE, cex=1.2, line=0.6)
   
})


pr_markersplot.opts = tagList(
    selectInput("pr_level","Level:", choices=c("gene","geneset")),
    selectInput("pr_features","Feature set:", choices=NULL, multiple=FALSE),
    textInput("pr_search","Filter:")
)
pr_markersplot_module <- plotModule(
    "pr_markersplot", pr_markersplotFUNC,
    info.text = "The Markers section produces for the top marker genes, a t-SNE with samples colored in red when the gene is overexpressed in corresponding samples. The top genes (N=36) with the highest standard deviation are plotted. <p>In the plotting options, users can also restrict the marker analysis by selecting a particular functional group in which genes are divided into 89 groups, such as chemokines, transcription factors, genes involved in immune checkpoint inhibition, and so on.",
    title = "Distribution of marker genes",
    pdf.height = 10, pdf.width=10, res=95,
    options = pr_markersplot.opts
)
##output$pr_markersplot <- pr_markersplot_module$render
##output$pr_markersplot_pdf <- pr_markersplot_module$pdf
output <- attachModule(output, pr_markersplot_module)

fillCol(height = "100%", flex = c(NA,1), 
        pr_markersplot_module$buttons,
        ##scatterD3Output("pcaplot", height = "100%")
        plotOutput("pr_markersplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    choices <- names(ngs$families)
    selected = grep("^CD",choices,ignore.case=TRUE,value=TRUE)[1]
    if(input$pr_level=="geneset") {
        choices <- names(COLLECTIONS)
        selected = grep("HALLMARK",names(COLLECTIONS),ignore.case=TRUE,value=TRUE)
    }
    updateSelectInput(session, "pr_features", choices=choices, selected=selected)
})

```

> **Distribution of marker genes.** T-SNE distribution plots of the top biomarkers for `r renderText(input$pr_features)` genes. Good biomarkers will show an expression pattern strongly correlated with some phenotype. The top genes with the highest standard deviation are shown. The red color shading is proportional to the (absolute) expression of the gene in corresponding samples. 


### CNV

```{r}

getCNAfromExpression <- reactive({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##source("../R/pgx-cna.R");source("../R/gx-heatmap.r")
    cat("<profiling:getCNAfromExpression> calculating CNV...\n")
    res <- pgx.CNAfromExpression(ngs, nsmooth=40, downsample=10) 
    return(res)
})

##output$pr_cnaplot <- renderPlot({
pr_cnaplotFUNC <- reactive({
    require(RColorBrewer)
    ##return(NULL)    
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    res <- getCNAfromExpression()
    if(is.null(res)) return(NULL)
    annotvar=NA
    annotvar <- input$pr_cna_annotvar
    if(annotvar=="<none>") annotvar <- NULL
    order.by <- input$pr_cna_orderby
    pgx.plotCNAHeatmap(ngs, res, annot=annotvar, order.by=order.by)
})

pr_cna.opts = tagList(
    selectInput("pr_cna_annotvar",label="Annotate with:", choices=NULL, multiple=FALSE),
    ##checkboxGroupInput('pr_cnaoptions','',c("bin20"), inline=TRUE),
    ##radioButtons('pr_cnaplottype',NULL,c("image","heatmap","splitmap"), inline=TRUE),
    radioButtons('pr_cna_orderby',"Order samples by:",c("clust","pc1"), inline=TRUE)            
)

pr_cnaModule <- plotModule(
    "pr_cnaplot", pr_cnaplotFUNC,
    info.text = "<strong>Copy number variation (CNV)</strong> analysis. The copy number is estimated from gene expression data by computing a moving average of the relative expression along the chromosomes. CNV generates a heatmap of samples versus chromosomes, where samples can be annotated further with a phenotype class provided in the data.",
    options = pr_cna.opts,
    title = "Inferred copy number variation (CNV)",
    pdf.width=10, pdf.height=8, res=110
)
##output$pr_cnaplot     <- pr_cnaModule$render
##output$pr_cnaplot_pdf <- pr_cnaModule$pdf   ## name must be exactly same
output <- attachModule(output, pr_cnaModule)

fillCol(height = "100%", flex = c(NA,1), 
        pr_cnaModule$buttons,
        plotOutput("pr_cnaplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ## levels for sample filter
    annotvar <- c(colnames(ngs$Y),"<none>")
    updateSelectInput(session, "pr_cna_annotvar", choices=annotvar)
})

```

> **Inferred copy number variation (CNV)**. Genomic copy number is estimated from gene expression data by computing a moving average of the relative expression along the chromosomes. The heatmap shows the inferred copy number of the samples versus chromosomes. The samples are annotated further with phenotype information on the right side of the figure.


Col {.tabset data-width=375}
----------------------------------------------------------------------------------------

### Phenotypes 

```{r}
##output$pr_phenoplot <- renderPlot({
pr_phenoplotFUNC <- reactive({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    
    clust <- pfGetClusterPositions()
    if(is.null(clust)) return(NULL)
    
    pos <- ngs$tsne2d
    pos <- clust$pos
    sel <- rownames(pos)
    pheno = colnames(ngs$Y)

    ## layout
    par(mfrow = c(3,2), mar=c(0.3,0.7,2.8,0.7))
    if(length(pheno)>6) par(mfrow = c(4,3), mar=c(0.3,0.4,2.8,0.4)*0.8)
    if(length(pheno)>12) par(mfrow = c(5,4), mar=c(0.2,0.2,2.5,0.2)*0.8)
    
    cex1 <- 1.6*c(1.8,1.3,0.8,0.5)[cut(nrow(pos),breaks=c(-1,40,200,1000,1e10))]    
    cex1 = cex1 * ifelse(length(pheno)>6, 0.8, 1)
    cex1 = cex1 * ifelse(length(pheno)>12, 0.8, 1)

    ## is it a float/number???
    is.num <- function(y, fmin=0.1) {
        suppressWarnings(numy <- as.numeric(as.character(y)))
        t1 <- !all(is.na(numy)) && is.numeric(numy)
        t2 <- (length(unique(y))/length(y)) > fmin
        (t1 && t2)
    }
    
    i=6    
    for(i in 1:min(20,length(pheno))) {

        px=4
        px=pheno[i]
        y = ngs$Y[sel,px]
        y[which(y %in% c(NA,""," ","NA","na"))] <- NA
        if(sum(!is.na(y))==0) next

        if(is.num(y)) {
            klrpal = colorRampPalette(c("grey90", "grey50", "red3"))(16)
            y = rank(as.numeric(y))
            ny <- round(1 + 15*(y - min(y))/(max(y)-min(y)))
            klr0 = klrpal[ny]
        } else {
            y = factor(as.character(y))
            klrpal = COLORS
            klrpal <- paste0(col2hex(klrpal),"99")
            klr0 = klrpal[y]
        }

        jj = which(is.na(klr0))
        if(length(jj)) klr0[jj] <- "#AAAAAA22"
        plot( pos, pch=19, cex=cex1, col=klr0,fg = gray(0.5), bty = "o",
             xaxt='n', yaxt='n', xlab="tSNE1", ylab="tSNE2")

        if(!is.num(y)) {
            if(input$pr_labelmode=="legend") {
                legend("bottomright", legend=levels(y), fill=klrpal,
                       cex=0.9, y.intersp=0.8, bg="white")
            } else {
                grp.pos <- apply(pos,2,function(x) tapply(x,y,mean,na.rm=TRUE))
                grp.pos <- apply(pos,2,function(x) tapply(x,y,median,na.rm=TRUE))
                nvar <- length(setdiff(y,NA))
                if(nvar==1) {
                    grp.pos <- matrix(grp.pos,nrow=1)
                    rownames(grp.pos) <- setdiff(y,NA)[1]
                }
                
                labels = rownames(grp.pos)
                ## title("\u2591\u2592\u2593") 
                boxes = sapply(nchar(labels),function(n) paste(rep("\u2588",n),collapse=""))
                boxes = sapply(nchar(labels),function(n) paste(rep("â–ˆ",n),collapse=""))
                ##boxes = sapply(nchar(labels),function(n) paste(rep("#",n),collapse=""))
                cex2 <- c(1.4,1.2,1,0.8)[cut(length(labels),breaks=c(-1,5,10,20,999))]    
                text( grp.pos, labels=boxes, cex=cex2, col="#CCCCCC99")
                text( grp.pos, labels=labels, font=2, cex=1.1*cex2, col="white")
                text( grp.pos, labels=labels, font=2, cex=cex2)
                ##text( grp.pos[,], labels=rownames(grp.pos), font=2, cex=cex1**0.5)
            }
        }
        title(tolower(pheno[i]), cex.main=1.3, line=0.5, col="grey40")
    }
})


pr_phenoplot.opts <- tagList(
    tipify( radioButtons('pr_labelmode','Label:',c("groups","legend"), inline=TRUE),
           "Select whether you want the group labels to be plotted inside the plots or in a seperate legend.")
)

pr_phenoModule <- plotModule(
    "pr_phenoplot", pr_phenoplotFUNC,
    info.text = "<strong>Phenotypes.</strong> This figure visualizes the distribution of
    the phenotype information. In the plot options, you can select whether you want the group labels to be plotted inside the plots or in a seperate legend.",
    options = pr_phenoplot.opts,
    pdf.width=5, pdf.height=8, res=90
)
output$pr_phenoplot <- pr_phenoModule$render
output$pr_phenoplot_pdf <- pr_phenoModule$pdf

fillCol(flex = c(NA,1), 
        pr_phenoModule$buttons,
        plotOutput("pr_phenoplot")
        )

```

> **Phenotype plots.** The plots show the distribution of the phenotypes superposed on the t-SNE clustering. Often, we can expect the t-SNE distribution to be driven by the particular phenotype that is controlled by the experimental condition or unwanted batch effects.



### Proportions


```{r}

##output$statsplot <- renderPlot({
pr_xtabplotFUNC <- reactive({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()

    req(ngs)
    req(input$pr_xtabpheno, input$pr_xtabvar, input$pr_xtabgene)
    
    scores = ngs$deconv[[1]][[1]]  ## just an example...
    if(input$pr_xtabvar == "<cell type>") {
        scores <- getDeconvResults()
        if(is.null(scores)) return(NULL)
        scores <- pmax(scores,0) ## ??
    } else {
        x <- as.character(ngs$Y[,1])
        x <- as.character(ngs$Y[,input$pr_xtabvar])
        x[is.na(x)] <- "_"
        scores <- model.matrix( ~ 0 + x )
        rownames(scores) <- rownames(ngs$Y)
        colnames(scores) <- sub("^x","",colnames(scores))
    }
    dim(scores)

    ## restrict to selected sample set
    kk <- head(1:nrow(scores),1000)
    kk <- 1:nrow(scores)
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    scores <- scores[kk,,drop=FALSE]
    scores <- scores[,which(colSums(scores)>0),drop=FALSE]
    scores[which(is.na(scores))] <- 0    
    dim(scores)

    ## expected counts per stat level
    ##kk.counts <- colSums(ngs$counts[,kk,drop=FALSE])  ## total count of selected samples
    kk.counts <- colSums(2**ngs$X[,kk,drop=FALSE])  ## approximate counts from log2X
    grp.counts <- ( t(scores / rowSums(scores)) %*% matrix(kk.counts,ncol=1))[,1]  
    
    getProportionsTable <- function(pheno, is.gene=FALSE) {    
        y <- NULL
        ##if("gene" %in% input$pr_xtaboptions) {
        if( is.gene ) {
            xgene <- ngs$genes[rownames(ngs$X),]$gene_name
            gx <- ngs$X[which(xgene == pheno),kk,drop=FALSE]
            gx.highTH <- mean(gx, na.rm=TRUE)
            y <- paste(pheno,c("low","high"))[ 1 + 1*(gx >= gx.highTH)]
            table(y)
        } else if(pheno %in% colnames(ngs$samples)) {
            y <- ngs$samples[kk,1]
            y <- ngs$samples[kk,pheno]
            pheno <- tolower(pheno)
        } else if(pheno == "<cell type>") {
            res1 <- getDeconvResults()
            res1 <- pmax(res1,0) ## ??
            res1 <- res1[kk,,drop=FALSE]
            ##res1 <- res1[,which(colSums(res1)>0),drop=FALSE]
            y <- colnames(res1)[max.col(res1)]  ## take maximum col??
            remove(res1)
            pheno <- "<cell type>"
        } else {
            return(NULL)
        }   
        
        ## calculate proportions by group
        grp <- factor(as.character(y))
        ngrp <- length(levels(grp))
        grp.score <- apply(scores, 2, function(x) tapply(x,grp,mean,na.rm=TRUE))
        ngrp
        if(ngrp==1) {
            grp.score <- matrix(grp.score,nrow=1)
            rownames(grp.score) <- y[1]
            colnames(grp.score) <- colnames(scores)
        }
        
        ## weighted counts
        grp.score[is.na(grp.score)] <- 0
        grps <- levels(grp)
        grp.score
        fy <-  (table(y) / sum(!is.na(y)))
        jj <- match(rownames(grp.score),names(fy))
        grp.score <-  grp.score * as.vector(fy[jj])
        ## normalize to total 100% 
        grp.score <- grp.score / (1e-20+sum(grp.score))
        
        ## reduce to maximum number of items (x-axis)
        if(0) {
            ##jj <- which(colSums(grp.score) > 0.001)
            jj <- order(-colSums(grp.score))
            j1 <- head(jj, 25)  ## define maximum number of items
            j0 <- setdiff(jj, j1)
            grp.score0 <- grp.score[,j1,drop=FALSE]
            grp.counts0 <- grp.counts[j1]
            if(length(j0)>0) {
                grp.score0 <- cbind( grp.score0, "other"=rowSums(grp.score[,j0,drop=FALSE]))
                grp.counts0 <- c(grp.counts0, "other"=sum(grp.counts[j0]))
            }
            grp.score <- grp.score0
            grp.counts <- grp.counts0
            grp.score <- t( t(grp.score) / (1e-20+colSums(grp.score)))  ##
        }
        
        ## normalize to total 100% and reduce to maximum number of items (y-axis)
        jj <- order(-rowSums(grp.score))
        j1 <- head(jj, 10)  ## define maximum number of items
        j0 <- setdiff(jj, j1)
        grp.score0 <- grp.score[j1,,drop=FALSE]
        if(length(j0)>0) {
            grp.score0 <- rbind( grp.score0, "other"=colSums(grp.score[j0,,drop=FALSE]))
        }
        grp.score <- grp.score0
        grp.score <- t( t(grp.score) / (1e-20+colSums(grp.score)))  ##

        ## cluster columns??
        ##dist1 <- dist(t(scale(grp.score)))
        dist1 <- dist(t(grp.score))
        dist1[is.na(dist1)] <- mean(dist1,na.rm=TRUE)
        jj <- hclust(dist1)$order
        grp.score <- grp.score[,jj,drop=FALSE]
        return(grp.score)
    }

    ## select phenotype variable
    head(ngs$samples)
    pheno=1
    pheno="cluster"
    pheno="activated"
    pheno="cell.type"
    pheno="<cell type>"
    pheno <- input$pr_xtabpheno
    if(is.null(pheno)) return(NULL)

    ##pheno="cluster"
    grp.score1 <- getProportionsTable(pheno, is.gene=FALSE)    
    grp.score2 <- NULL
    gene = ngs$genes$gene_name[1]
    gene = input$pr_xtabgene
    if(gene != "<none>") {
        grp.score2 <- getProportionsTable(pheno=gene, is.gene=TRUE)
        kk <- colnames(grp.score2)[order(grp.score2[1,])]
        grp.score2  <- grp.score2[,match(kk,colnames(grp.score2))]
        grp.score1  <- grp.score1[,match(kk,colnames(grp.score1))]
    }
    
    jj <- match(colnames(grp.score1),names(grp.counts))
    grp.counts <- grp.counts[jj] / 1e6  ## per million
    names(grp.counts) = colnames(grp.score1)

    ##-------------- plot by estimated cell.type ----------------------
    
    ##par(mar = c(4,6,2,3))
    layout(matrix(c(1,2,3), 3,1), heights=c(2,4,3))
    if(!is.null(grp.score2)) {
        layout(matrix(c(1,2,3,4), 4,1), heights=c(2.2,1,4,2))
    }
    
    ## top bar with counts
    par(mar = c(0,5,5.3,3), mgp=c(2.0,0.8,0) )
    xlim <- c(0,1.2*length(grp.counts))  ## reserves space for legend
    barplot( grp.counts, col="grey50", ylab="counts (M)", cex.axis=0.8,
            cex.lab=0.8, names.arg=NA, xpd=NA, xlim=1.3*xlim, ## log="y", 
            ylim=c(0.01, max(grp.counts)), yaxs="i" )
    ## title(pheno, cex.main=1.2, line=2, col="grey40")
    
    ## middle plot (gene)
    if(!is.null(grp.score2)) {
        klrpal2 = COLORS[1:nrow(grp.score2)]
        klrpal2 = rev(grey.colors(nrow(grp.score2),start=0.45))
        par(mar = c(0,5,0.3,3), mgp=c(2.4,0.9,0) )
        barplot( 100*grp.score2, col=klrpal2, las=3, srt=45,
                xlim=1.3*xlim, ylim=c(0,99.99),
                names.arg = rep(NA, ncol(grp.score2)),
                ylab="(%)", cex.axis=0.90)
        legend(1.02*xlim[2], 100, legend=rownames(grp.score2),
               fill=klrpal2, xpd=TRUE, cex=0.8, y.intersp=0.8,
               bg="white", bty="n")
    }

    if(1) {
        ## main proportion graph
        klrpal1 = COLORS[1:nrow(grp.score1)]
        par(mar = c(4,5,0.3,3), mgp=c(2.4,0.9,0) )
        barplot( 100*grp.score1, col=klrpal1, las=3, srt=45, xlim=1.3*xlim,
                ylim=c(0,99.99), ylab="proportion (%)", cex.axis=0.90)
        legend(1.02*xlim[2], 100, legend=rev(rownames(grp.score1)),
               fill=rev(klrpal1), xpd=TRUE, cex=0.8, y.intersp=0.8,
           bg="white", bty="n")
    }
    
})


pr_xtab.opts <- tagList(
    selectInput("pr_xtabvar",label="x-axis:", choices=NULL, multiple=FALSE),
    selectInput("pr_xtabpheno",label="y-axis:", choices=NULL, multiple=FALSE),
    selectInput("pr_xtabgene",label="gene:", choices=NULL, multiple=FALSE)
    ##checkboxGroupInput('pr_xtaboptions','',c("gene"), inline=TRUE, width='50px')
    ##selectInput("pr_xtabgene",label=NULL, choices=NULL, multiple=FALSE),
    ##br(), cellArgs=list(width='80px')
)

pr_xtabModule <- plotModule(
    "pr_xtabplot", pr_xtabplotFUNC,
    info.text = "The <strong>Proportions tab</strong> visualizes the interrelationships between two categorical variables (so-called cross tabulation). Although this feature is very suitable for a single-cell sequencing data, it provides useful information about the proportion of different cell types in samples obtained by the bulk sequencing method.",
    options = pr_xtab.opts,
    pdf.width=6, pdf.height=8, res=110
)
output$pr_xtabplot <- pr_xtabModule$render
output$pr_xtabplot_pdf <- pr_xtabModule$pdf

fillCol(flex = c(NA,1), 
        pr_xtabModule$buttons,
        plotOutput("pr_xtabplot")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    ##if(is.null(input$pr_xtaboptions)) return(NULL)
    pheno0 <- grep("group|sample|donor|id|batch",colnames(ngs$samples),invert=TRUE,value=TRUE)
    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)
    nphenolevel <- apply(ngs$samples[kk,pheno0],2,function(v) length(unique(v)))
    pheno0 = pheno0[which(nphenolevel>1)]
    genes <- sort(as.character(ngs$genes$gene_name))
    pheno1 <- c("<cell type>",pheno0)
    genes1 <- c("<none>",genes)
    updateSelectInput(session, "pr_xtabvar", choices=pheno1)
    updateSelectInput(session, "pr_xtabpheno", choices=pheno1)
    updateSelectInput(session, "pr_xtabgene", choices=genes1)
})

```

> **Proportion plot.** visualizes the interrelationships between two categorical variables (so-called cross tabulation). Although this feature is very suitable for a single-cell sequencing data, it provides useful information about the proportion of different cell types in samples obtained by the bulk sequencing method.


### CytoPlot

```{r}

##output$pr_cytoplot <- renderPlot({
pr_cytoplotFUNC <- reactive({
    ##if(!input$tsne.all) return(NULL)
    require(RColorBrewer)
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    if(is.null(input$pr_cytovar1)) return(NULL)
    if(is.null(input$pr_cytovar2)) return(NULL)

    kk <- selectSamplesFromSelectedLevels(ngs$Y, input$pr_samplefilter)    
    gene1 <- input$pr_cytovar1
    gene2 <- input$pr_cytovar2
    ##if(gene1 == gene2) return(NULL)
    par(mfrow=c(1,1), mar=c(12,4,6,2))
    pgx.cytoPlot( ngs, gene1, gene2, samples=kk, cex=0.8,
                 col="grey60", cex.names=1)
    
})

pr_cyto.opts = tagList(
    selectInput("pr_cytovar1",label="x-axis:", choices=NULL, multiple=FALSE),
    selectInput("pr_cytovar2",label="y-axis:", choices=NULL, multiple=FALSE)
)

pr_cytoModule <- plotModule(
    "pr_cytoplot", pr_cytoplotFUNC,
    info.text = "For each combination of gene pairs, the platform can generate a cytometry-like plot of samples under the Cytoplot tab. The aim of this feature is to observe the distribution of samples in relation to the selected gene pairs. For instance, when applied to single-cell sequencing data from immunological cells, it can mimic flow cytometry analysis and distinguish T helper cells from the other T cells by selecting the CD4 and CD8 gene combination.",
    options = pr_cyto.opts,
    pdf.width=6, pdf.height=8, res=80
)
output$pr_cytoplot <- pr_cytoModule$render
output$pr_cytoplot_pdf <- pr_cytoModule$pdf
fillCol(flex = c(NA, 1), 
        pr_cytoModule$buttons,
        plotOutput("pr_cytoplot", height = "100%")
        )

observe({
    ngs <- inputData()
    if(is.null(ngs)) return(NULL)
    xgenes <- ngs$genes[rownames(ngs$X),]$gene_name
    genes <- sort(as.character(xgenes))
    g1 <- grep("^CD4|^CD8",genes,value=TRUE)[1]
    g2 <- grep("^CD79|^CD3[DEG]|^CD37",genes,value=TRUE)[1]
    updateSelectInput(session, "pr_cytovar1", choices=genes, selected=g1)
    updateSelectInput(session, "pr_cytovar2", choices=genes, selected=g2)
})

```

> **Cyto plot.** This plot shows the distribution of samples in relation to the expression of selected gene pairs. It mimics the scatter plots used for gating in flow cytometry analysis.

